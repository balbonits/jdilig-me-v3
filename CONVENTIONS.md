# Project Conventions & Architecture

## 📁 Project Structure

```
src/
├── components/           # Reusable UI components
│   ├── ui/              # Basic UI elements (buttons, inputs, etc.)
│   ├── forms/           # Form-related components
│   ├── layout/          # Layout components (headers, sidebars)
│   ├── feedback/        # User feedback (modals, toasts, alerts)
│   └── data-display/    # Data visualization components
├── layouts/             # Page layouts
│   └── RootLayout/      # Main app layout with header/footer
├── templates/           # Page templates
│   ├── PageTemplate/    # Standard page template
│   ├── HeroTemplate/    # Hero section template
│   └── GridTemplate/    # Grid layout template
├── pages/               # Route pages
└── router/              # Routing configuration

public/                  # All static assets (served from root)
├── images/              # Image files
├── fonts/               # Web fonts
├── icons/               # Icon files and PWA icons
├── favicon.ico          # Site favicon
├── manifest.json        # PWA manifest
└── John_Dilig_resume.pdf # Downloadable resume
```

## 🗂️ Component Organization

Each component lives in its own folder with all related files:

```
components/ui/Button/
├── Button.tsx           # Component implementation
├── Button.test.tsx      # Unit tests
├── Button.stories.ts    # Storybook stories
├── Button.module.css    # CSS modules (optional)
└── index.ts            # Barrel export
```

## 📦 Static Assets

**All assets go in `/public/`** - Simple, consistent approach:
- `/public/images/` - All images
- `/public/fonts/` - Web fonts
- `/public/icons/` - Icons and PWA icons
- `/public/John_Dilig_resume.pdf` - Downloadable resume (direct link)

Reference assets with absolute paths:
```tsx
// ✅ Correct
<img src="/images/logo.png" alt="Logo" />
<a href="/John_Dilig_resume.pdf" download>Download Resume</a>

// ❌ Don't import from src/assets (folder doesn't exist)
import logo from '../assets/logo.png';
```

## 🎨 Styling Approach

### Primary: Tailwind CSS
- Use utility classes for styling
- Compose classes using template literals
- Pattern: base + variant + size classes

```typescript
const baseClasses = 'font-medium rounded-lg';
const variantClasses = {
  primary: 'bg-blue-600 hover:bg-blue-700',
  secondary: 'bg-gray-600 hover:bg-gray-700'
};
const classes = `${baseClasses} ${variantClasses[variant]}`;
```

### Secondary: CSS Modules (when needed)
- Use `.module.css` for complex component-specific styles
- Scoped to component, no global pollution

## 📝 TypeScript Conventions

### Semicolons
- **ALWAYS use semicolons** - Explicit statement termination
- Enforced by ESLint rule: `'semi': ['error', 'always']`
- Prevents ASI (Automatic Semicolon Insertion) issues
- Makes code more explicit and maintainable

```typescript
// ✅ Correct
const name = 'John';
return <Component />;
import { useState } from 'react';

// ❌ Incorrect
const name = 'John'
return <Component />
import { useState } from 'react'
```

### Imports
- Use `import type` for type-only imports
- Required by `verbatimModuleSyntax` in tsconfig
- Always terminate with semicolons

```typescript
import type { ReactNode } from 'react';
import { useState } from 'react';
```

### Props
- Use `interface` for component props (not `type`)
- Descriptive names ending with `Props`
- Document complex props with JSDoc comments

```typescript
interface ButtonProps {
  /** Button variant style */
  variant?: 'primary' | 'secondary';
  children: ReactNode;
  onClick?: () => void;
}
```

## 🧪 Testing Strategy

### Unit Tests (Vitest)
- Co-located with components (`*.test.tsx`)
- Use `describe/it` pattern
- Test user interactions and visual states
- Mock with `vi.fn()`

```typescript
describe('Button', () => {
  it('renders children correctly', () => {
    render(<Button>Click me</Button>);
    expect(screen.getByText('Click me')).toBeInTheDocument();
  });
});
```

### E2E Tests (Playwright)
- Located in `/tests/` directory
- Test user workflows
- Multi-browser testing

## 📚 Storybook Organization

Stories follow component categories:

```
UI/Button
Forms/Input
Layout/Header
Feedback/Modal
DataDisplay/Chart
```

## 🚦 Routing (React Router v6)

- File-based route organization in `/pages/`
- Centralized routing in `/router/AppRouter.tsx`
- Layouts use `<Outlet />` for nested routes
- Error boundaries for 404 handling

```typescript
const router = createBrowserRouter([
  {
    path: '/',
    element: <RootLayout />,
    errorElement: <NotFoundPage />,
    children: [/* routes */]
  }
]);
```

## 📱 PWA Configuration

- Manifest in `public/manifest.json`
- Service worker auto-generated by Vite PWA plugin
- Offline caching strategy configured in `vite.config.ts`
- Icons required: 192x192 and 512x512 PNG

## 🏗️ Template System

### Layout Components
- `RootLayout`: Main app wrapper with header/footer
- Handles navigation and global UI elements

### Page Templates
- `PageTemplate`: Standard page with title/content
- `HeroTemplate`: Landing page hero sections
- `GridTemplate`: Grid-based content layouts

### Usage Pattern
```typescript
<RootLayout>
  <PageTemplate title="About" subtitle="Learn more">
    <YourContent />
  </PageTemplate>
</RootLayout>
```

## 🔧 Development Workflow

### Scripts
- `npm run dev` - Start dev server
- `npm run build` - Build for production
- `npm run build:ssg` - Build with static site generation
- `npm run test` - Run unit tests
- `npm run lint` - Check code quality
- `npm run storybook` - Component development

### Code Quality
- ESLint with TypeScript support
- Strict TypeScript settings
- No unused variables/imports
- Fix issues, don't disable rules
- Semicolons required

## 🚀 Deployment (Vercel)

- Framework: Vite
- Build command: `npm run build` (or `build:ssg` for static)
- Output directory: `dist`
- Configured in `vercel.json`

## 🚀 Best Practices

1. **Component Design**
   - Single responsibility
   - Composition over inheritance
   - Props for configuration
   - Children for content

2. **File Organization**
   - Related files stay together
   - Clear naming conventions
   - Barrel exports for clean imports

3. **State Management**
   - Local state with useState
   - Context for cross-component state
   - Consider external store for complex apps

4. **Performance**
   - Lazy load routes
   - Optimize images
   - Use React.memo sparingly
   - Profile before optimizing

5. **Accessibility**
   - Semantic HTML
   - ARIA labels where needed
   - Keyboard navigation
   - Color contrast compliance